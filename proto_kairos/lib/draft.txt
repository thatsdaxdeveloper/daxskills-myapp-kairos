import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:proto_kairos/views/themes/theme_app.dart';

class TimePickerControl extends StatefulWidget {
  final TimeOfDay? initialTime;
  final Function(TimeOfDay)? onTimeSelected;
  final Color? primaryColor;

  const TimePickerControl({
    super.key,
    this.initialTime,
    this.onTimeSelected,
    this.primaryColor,
  });

  @override
  State<TimePickerControl> createState() => _TimePickerControlState();

  static Future<TimeOfDay?> showTimePicker({
    required BuildContext context,
    TimeOfDay? initialTime,
    Color? primaryColor,
  }) async {
    TimeOfDay? selectedTime;

    await showDialog(
      context: context,
      builder: (context) => Dialog(
        backgroundColor: Colors.transparent,
        child: TimePickerControl(
          initialTime: initialTime,
          onTimeSelected: (time) {
            selectedTime = time;
            Navigator.of(context).pop();
          },
          primaryColor: primaryColor,
        ),
      ),
    );

    return selectedTime;
  }
}

class _TimePickerControlState extends State<TimePickerControl> {
  late TimeOfDay _selectedTime;
  bool _isAm = true;
  late FixedExtentScrollController _hourController;
  late FixedExtentScrollController _minuteController;

  @override
  void initState() {
    super.initState();
    _selectedTime = widget.initialTime ?? TimeOfDay.now();
    _hourController = FixedExtentScrollController(
      initialItem: _selectedTime.hourOfPeriod - 1, // -1 car l'index commence à 0
    );
    _minuteController = FixedExtentScrollController(
      initialItem: _selectedTime.minute ~/ 5, // Pas de 5 minutes
    );
    _isAm = _selectedTime.hour < 12;
  }

  @override
  void dispose() {
    _hourController.dispose();
    _minuteController.dispose();
    super.dispose();
  }

  List<Widget> _buildHours() {
    return List.generate(12, (index) {
      final hour = index + 1; // 1-12
      return Center(
        child: Text(
          hour.toString().padLeft(2, '0'),
          style: TextStyle(
            fontSize: 20.sp,
            color: Colors.white,
          ),
        ),
      );
    });
  }

  List<Widget> _buildMinutes() {
    return List.generate(12, (index) {
      final minute = index * 5; // 0, 5, 10, ..., 55
      return Center(
        child: Text(
          minute.toString().padLeft(2, '0'),
          style: TextStyle(
            fontSize: 20.sp,
            color: Colors.white,
          ),
        ),
      );
    });
  }

  void _onTimeChanged() {
    final hour = _hourController.selectedItem + 1; // 1-12
    final minute = _minuteController.selectedItem * 5; // 0, 5, 10, ..., 55

    setState(() {
      _selectedTime = TimeOfDay(
        hour: _isAm
            ? (hour == 12 ? 0 : hour)
            : (hour == 12 ? 12 : hour + 12),
        minute: minute,
      );
    });

    if (widget.onTimeSelected != null) {
      widget.onTimeSelected!(_selectedTime);
    }
  }

  @override
  Widget build(BuildContext context) {
    final primaryColor = widget.primaryColor ?? Theme.of(context).primaryColor;
    final textTheme = Theme.of(context).textTheme;

    return Container(
      padding: EdgeInsets.all(16.w),
      decoration: BoxDecoration(
        color: ThemeApp.eerieBlack,
        borderRadius: BorderRadius.circular(12.r),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Affichage de l'heure sélectionnée
          Container(
            padding: EdgeInsets.symmetric(vertical: 16.h),
            child: Text(
              _selectedTime.format(context),
              style: textTheme.headlineMedium?.copyWith(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),

          // Sélecteur d'heure
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Heures
              SizedBox(
                width: 80.w,
                height: 180.h,
                child: ListWheelScrollView.useDelegate(
                  controller: _hourController,
                  itemExtent: 50.h,
                  perspective: 0.01,
                  diameterRatio: 1.2,
                  onSelectedItemChanged: (_) => _onTimeChanged(),
                  physics: const FixedExtentScrollPhysics(),
                  childDelegate: ListWheelChildListDelegate(
                    children: _buildHours(),
                  ),
                ),
              ),

              // Séparateur
              Text(
                ':',
                style: textTheme.headlineMedium?.copyWith(
                  color: Colors.white,
                ),
              ),

              // Minutes
              SizedBox(
                width: 80.w,
                height: 180.h,
                child: ListWheelScrollView.useDelegate(
                  controller: _minuteController,
                  itemExtent: 50.h,
                  perspective: 0.01,
                  diameterRatio: 1.2,
                  onSelectedItemChanged: (_) => _onTimeChanged(),
                  physics: const FixedExtentScrollPhysics(),
                  childDelegate: ListWheelChildListDelegate(
                    children: _buildMinutes(),
                  ),
                ),
              ),

              // AM/PM
              Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  _buildAmPmButton('AM', true, primaryColor),
                  SizedBox(height: 8.h),
                  _buildAmPmButton('PM', false, primaryColor),
                ],
              ),
            ],
          ),

          // Bouton de validation
          if (widget.onTimeSelected != null) ...[
            SizedBox(height: 16.h),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => widget.onTimeSelected!(_selectedTime),
                style: ElevatedButton.styleFrom(
                  backgroundColor: primaryColor,
                  padding: EdgeInsets.symmetric(vertical: 12.h),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8.r),
                  ),
                ),
                child: Text(
                  'Valider',
                  style: textTheme.bodyLarge?.copyWith(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildAmPmButton(String label, bool isAm, Color primaryColor) {
    final isSelected = _isAm == isAm;

    return GestureDetector(
      onTap: () {
        setState(() {
          _isAm = isAm;
          _onTimeChanged();
        });
      },
      child: Container(
        padding: EdgeInsets.symmetric(horizontal: 16.w, vertical: 6.h),
        decoration: BoxDecoration(
          color: isSelected ? primaryColor : Colors.transparent,
          borderRadius: BorderRadius.circular(20.r),
          border: Border.all(
            color: isSelected ? primaryColor : ThemeApp.trueWhite.withOpacity(0.2),
            width: 1.w,
          ),
        ),
        child: Text(
          label,
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            color: isSelected ? Colors.white : ThemeApp.trueWhite.withOpacity(0.7),
            fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
          ),
        ),
      ),
    );
  }
}

extension TimeOfDayExtension on TimeOfDay {
  int get hourOfPeriod => hour == 0 ? 12 : (hour > 12 ? hour - 12 : hour);
}

==============================================================================================
==============================================================================================
==============================================================================================
==============================================================================================
==============================================================================================

import 'package:flutter/material.dart';
import 'package:flutter_heatmap_calendar/flutter_heatmap_calendar.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:intl/intl.dart';
import 'package:proto_kairos/models/data/generated/assets.dart';
import 'package:proto_kairos/views/themes/theme_app.dart';
import 'package:proto_kairos/views/utils/svg_util.dart';

class DatePickerControl extends StatefulWidget {
  const DatePickerControl({super.key});

  @override
  State<DatePickerControl> createState() => _DatePickerControlState();
}

class _DatePickerControlState extends State<DatePickerControl> {
  final Map<DateTime, int> _events = {};
  final Map<DateTime, bool> selectedDates = {};

  void _onDateSelected(DateTime date) {
    setState(() {
      selectedDates[date] = !(selectedDates[date] ?? false);
    });
  }

  @override
  Widget build(BuildContext context) {
    final TextTheme textTheme = Theme.of(context).textTheme;
    final Color primaryColor = Theme.of(context).primaryColor;
    return CustomCalendar(selectedDates: selectedDates, onDateSelected: _onDateSelected);
  }
}

class CustomCalendar extends StatefulWidget {
  final Function(DateTime)? onDateSelected;
  final Map<DateTime, bool> selectedDates;

  const CustomCalendar({super.key, this.onDateSelected, required this.selectedDates});

  @override
  State<CustomCalendar> createState() => _CustomCalendarState();
}

class _CustomCalendarState extends State<CustomCalendar> {
  late DateTime _currentMonth;
  final List<String> _weekDays = ['L', 'M', 'M', 'J', 'V', 'S', 'D'];

  @override
  void initState() {
    super.initState();
    _currentMonth = DateTime.now();
  }

  List<DateTime> _getDaysInMonth(DateTime month) {
    final firstDay = DateTime(month.year, month.month, 1);
    final lastDay = DateTime(month.year, month.month + 1, 0);

    // Obtenir le premier jour de la semaine (0 = lundi, 6 = dimanche)
    int firstWeekday = firstDay.weekday - 1; // Convertir à 0-indexé (lundi=0)
    if (firstWeekday < 0) firstWeekday = 6; // Si dimanche, mettre à 6

    List<DateTime> days = [];

    // Ajouter les jours du mois précédent
    if (firstWeekday > 0) {
      final prevMonth = DateTime(month.year, month.month - 1, 0);
      final daysInPrevMonth = prevMonth.day;

      for (int i = firstWeekday - 1; i >= 0; i--) {
        days.add(DateTime(prevMonth.year, prevMonth.month, daysInPrevMonth - i));
      }
    }

    // Ajouter les jours du mois courant
    for (int i = 1; i <= lastDay.day; i++) {
      days.add(DateTime(month.year, month.month, i));
    }

    // Ajouter les jours du mois suivant pour compléter la grille
    final nextMonth = month.month == 12
        ? DateTime(month.year + 1, 1, 1)
        : DateTime(month.year, month.month + 1, 1);

    // Ajouter des jours jusqu'à compléter la dernière semaine
    int dayNumber = 1;
    while (days.length % 7 != 0) {
      days.add(DateTime(nextMonth.year, nextMonth.month, dayNumber));
      dayNumber++;
    }

    return days;
  }

  @override
  Widget build(BuildContext context) {
    final days = _getDaysInMonth(_currentMonth);
    final primaryColor = Theme.of(context).primaryColor;
    final textTheme = Theme.of(context).textTheme;

    return Column(
      children: [
        SizedBox(height: 6.h),

        // En-tête du mois
        _buildMonthHeader(),
        SizedBox(height: 6.h),

        // Jours de la semaine
        _buildWeekDays(),

        // Jours du mois
        SizedBox(
          height: 250.h,
          child: GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 7, childAspectRatio: 1.0),
            itemCount: days.length,
            itemBuilder: (context, index) {
              final date = days[index];
              final isCurrentMonth = date.month == _currentMonth.month;
              final isSelected = widget.selectedDates[date] ?? false;
              final now = DateTime.now();
              final isToday = date.year == now.year &&
                            date.month == now.month &&
                            date.day == now.day;

              return GestureDetector(
                onTap: () {
                  final now = DateTime.now();
                  final today = DateTime(now.year, now.month, now.day);
                  final selectedDate = DateTime(date.year, date.month, date.day);

                  if (isCurrentMonth && !selectedDate.isBefore(today)) {
                    widget.onDateSelected?.call(date);
                  }
                },
                child: Container(
                  margin: EdgeInsets.all(2.w),
                  decoration: BoxDecoration(
                    border: isToday ? Border.all(color: primaryColor, width: 2.w) : null,
                    color: isSelected
                        ? primaryColor
                        : isCurrentMonth
                        ? ThemeApp.trueWhite.withValues(alpha: 0.06)
                        : Colors.transparent,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Align(
                    alignment: Alignment.center,
                    child: Padding(
                      padding: EdgeInsets.all(4.0.w),
                      child: Text(
                        date.day.toString(),
                        style: textTheme.bodySmall!.copyWith(
                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                          fontSize: isSelected ? 16.sp : 12.sp,
                          color: isSelected
                              ? Colors.white
                              : isCurrentMonth
                              ? Colors.white
                              : Colors.white.withValues(alpha: 0.3),
                        )
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildMonthHeader() {
    final monthYear = DateFormat('MMMM yyyy', 'fr_FR').format(_currentMonth);
    return Container(
      margin: EdgeInsets.symmetric(horizontal: 10.w),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          GestureDetector(
            onTap: () {
              setState(() {
                _currentMonth = DateTime(_currentMonth.year, _currentMonth.month - 1);
              });
            },
            child: svgIcon(path: Assets.chevronLeftSquareSvgrepoCom),
          ),

          Text(
            "${monthYear[0].toUpperCase()}${monthYear.substring(1)}",
            style: Theme.of(context).textTheme.headlineMedium,
          ),

          GestureDetector(
            onTap: () {
              setState(() {
                _currentMonth = DateTime(_currentMonth.year, _currentMonth.month + 1);
              });
            },
            child: svgIcon(path: Assets.chevronRightSquareSvgrepoCom),
          ),
        ],
      ),
    );
  }

  Widget _buildWeekDays() {
    return GridView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 7),
      itemCount: 7,
      itemBuilder: (context, index) {
        return Center(
          child: Text(
            _weekDays[index],
            style: Theme.of(context).textTheme.bodyMedium!.copyWith(color: ThemeApp.trueWhite.withValues(alpha: 0.8)),
          ),
        );
      },
    );
  }

}
